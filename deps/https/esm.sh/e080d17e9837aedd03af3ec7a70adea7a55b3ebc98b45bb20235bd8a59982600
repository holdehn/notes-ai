/* esm.sh - esbuild bundle(detect-libc@2.0.1) deno production */
import __Process$ from "https://deno.land/std@0.177.0/node/process.ts";import __1$ from "https://deno.land/std@0.177.0/node/child_process.ts";var U=Object.create;var m=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,P=Object.prototype.hasOwnProperty;var E=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var r in e)m(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,l)=>{if(e&&typeof e=="object"||typeof e=="function")for(let u of q(e))!P.call(n,u)&&u!==r&&m(n,u,{get:()=>e[u],enumerable:!(l=j(e,u))||l.enumerable});return n},o=(n,e,r)=>(a(n,e,"default"),r&&a(r,e,"default")),x=(n,e,r)=>(r=n!=null?U(A(n)):{},a(e||!n||!n.__esModule?m(r,"default",{value:n,enumerable:!0}):r,n));var g=y((on,b)=>{"use strict";var S=()=>__Process$.platform==="linux",d=null,z=()=>(d||(d=S()&&__Process$.report?__Process$.report.getReport():{}),d);b.exports={isLinux:S,getReport:z}});var p=y((cn,V)=>{"use strict";var v=__1$,{isLinux:c,getReport:h}=g(),R="getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",t="",_=()=>t||new Promise(n=>{v.exec(R,(e,r)=>{t=e?" ":r,n(t)})}),C=()=>{if(!t)try{t=v.execSync(R,{encoding:"utf8"})}catch{t=" "}return t},i="glibc",f="musl",D=n=>n.includes("libc.musl-")||n.includes("ld-musl-"),G=()=>{let n=h();return n.header&&n.header.glibcVersionRuntime?i:Array.isArray(n.sharedObjects)&&n.sharedObjects.some(D)?f:null},N=n=>{let[e,r]=n.split(/[\r\n]+/);return e&&e.includes(i)?i:r&&r.includes(f)?f:null},F=async()=>{let n=null;if(c()&&(n=G(),!n)){let e=await _();n=N(e)}return n},w=()=>{let n=null;if(c()&&(n=G(),!n)){let e=C();n=N(e)}return n},H=async()=>c()&&await F()!==i,J=()=>c()&&w()!==i,I=()=>{let n=h();return n.header&&n.header.glibcVersionRuntime?n.header.glibcVersionRuntime:null},L=n=>n.trim().split(/\s+/)[1],O=n=>{let[e,r,l]=n.split(/[\r\n]+/);return e&&e.includes(i)?L(e):r&&l&&r.includes(f)?L(l):null},K=async()=>{let n=null;if(c()&&(n=I(),!n)){let e=await _();n=O(e)}return n},Q=()=>{let n=null;if(c()&&(n=I(),!n)){let e=C();n=O(e)}return n};V.exports={GLIBC:i,MUSL:f,family:F,familySync:w,isNonGlibcLinux:H,isNonGlibcLinuxSync:J,version:K,versionSync:Q}});var s={};k(s,{GLIBC:()=>T,MUSL:()=>W,default:()=>tn,family:()=>X,familySync:()=>Y,isNonGlibcLinux:()=>Z,isNonGlibcLinuxSync:()=>$,version:()=>nn,versionSync:()=>en});var M=x(p());o(s,x(p()));var{GLIBC:T,MUSL:W,family:X,familySync:Y,isNonGlibcLinux:Z,isNonGlibcLinuxSync:$,version:nn,versionSync:en}=M,{default:B,...rn}=M,tn=B!==void 0?B:rn;export{T as GLIBC,W as MUSL,tn as default,X as family,Y as familySync,Z as isNonGlibcLinux,$ as isNonGlibcLinuxSync,nn as version,en as versionSync};
//# sourceMappingURL=detect-libc.mjs.map