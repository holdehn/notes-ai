/* esm.sh - esbuild bundle(@supabase/realtime-js@2.7.2/dist/module/RealtimeChannel) deno production */
import{CHANNEL_EVENTS as w,CHANNEL_STATES as v}from"/v124/@supabase/realtime-js@2.7.2/deno/dist/module/lib/constants.js";import k from"/v124/@supabase/realtime-js@2.7.2/deno/dist/module/lib/push.js";import D from"/v124/@supabase/realtime-js@2.7.2/deno/dist/module/lib/timer.js";import N from"/v124/@supabase/realtime-js@2.7.2/deno/dist/module/RealtimePresence.js";import*as P from"/v124/@supabase/realtime-js@2.7.2/deno/dist/module/lib/transformers.js";var y=function(c,e,t,i){function s(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function g(a){try{h(i.next(a))}catch(m){o(m)}}function L(a){try{h(i.throw(a))}catch(m){o(m)}}function h(a){a.done?n(a.value):s(a.value).then(g,L)}h((i=i.apply(c,e||[])).next())})},O;(function(c){c.ALL="*",c.INSERT="INSERT",c.UPDATE="UPDATE",c.DELETE="DELETE"})(O||(O={}));var T;(function(c){c.BROADCAST="broadcast",c.PRESENCE="presence",c.POSTGRES_CHANGES="postgres_changes"})(T||(T={}));var R;(function(c){c.SUBSCRIBED="SUBSCRIBED",c.TIMED_OUT="TIMED_OUT",c.CLOSED="CLOSED",c.CHANNEL_ERROR="CHANNEL_ERROR"})(R||(R={}));var C=class{constructor(e,t={config:{}},i){this.topic=e,this.params=t,this.socket=i,this.bindings={},this.state=v.closed,this.joinedOnce=!1,this.pushBuffer=[],this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:""}},t.config),this.timeout=this.socket.timeout,this.joinPush=new k(this,w.join,this.params,this.timeout),this.rejoinTimer=new D(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=v.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(s=>s.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=v.closed,this.socket._remove(this)}),this._onError(s=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,s),this.state=v.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=v.errored,this.rejoinTimer.scheduleTimeout())}),this._on(w.reply,{},(s,n)=>{this._trigger(this._replyEventName(n),s)}),this.presence=new N(this)}subscribe(e,t=this.timeout){var i,s;if(this.joinedOnce)throw"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";{let{config:{broadcast:n,presence:o}}=this.params;this._onError(h=>e&&e("CHANNEL_ERROR",h)),this._onClose(()=>e&&e("CLOSED"));let g={},L={broadcast:n,presence:o,postgres_changes:(s=(i=this.bindings.postgres_changes)===null||i===void 0?void 0:i.map(h=>h.filter))!==null&&s!==void 0?s:[]};this.socket.accessToken&&(g.access_token=this.socket.accessToken),this.updateJoinPayload(Object.assign({config:L},g)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",({postgres_changes:h})=>{var a;if(this.socket.accessToken&&this.socket.setAuth(this.socket.accessToken),h===void 0){e&&e("SUBSCRIBED");return}else{let m=this.bindings.postgres_changes,_=(a=m?.length)!==null&&a!==void 0?a:0,r=[];for(let u=0;u<_;u++){let l=m[u],{filter:{event:f,schema:p,table:j,filter:b}}=l,d=h&&h[u];if(d&&d.event===f&&d.schema===p&&d.table===j&&d.filter===b)r.push(Object.assign(Object.assign({},l),{id:d.id}));else{this.unsubscribe(),e&&e("CHANNEL_ERROR",new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=r,e&&e("SUBSCRIBED");return}}).receive("error",h=>{e&&e("CHANNEL_ERROR",new Error(JSON.stringify(Object.values(h).join(", ")||"error")))}).receive("timeout",()=>{e&&e("TIMED_OUT")})}return this}presenceState(){return this.presence.state}track(e,t={}){return y(this,void 0,void 0,function*(){return yield this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)})}untrack(e={}){return y(this,void 0,void 0,function*(){return yield this.send({type:"presence",event:"untrack"},e)})}on(e,t,i){return this._on(e,t,i)}send(e,t={}){return new Promise(i=>{var s,n,o;let g=this._push(e.type,e,t.timeout||this.timeout);g.rateLimited&&i("rate limited"),e.type==="broadcast"&&!(!((o=(n=(s=this.params)===null||s===void 0?void 0:s.config)===null||n===void 0?void 0:n.broadcast)===null||o===void 0)&&o.ack)&&i("ok"),g.receive("ok",()=>i("ok")),g.receive("timeout",()=>i("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=v.leaving;let t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(w.close,"leave",this._joinRef())};return this.rejoinTimer.reset(),this.joinPush.destroy(),new Promise(i=>{let s=new k(this,w.leave,{},e);s.receive("ok",()=>{t(),i("ok")}).receive("timeout",()=>{t(),i("timed out")}).receive("error",()=>{i("error")}),s.send(),this._canPush()||s.trigger("ok",{})})}_push(e,t,i=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let s=new k(this,e,t,i);return this._canPush()?s.send():(s.startTimeout(),this.pushBuffer.push(s)),s}_onMessage(e,t,i){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,i){var s,n;let o=e.toLocaleLowerCase(),{close:g,error:L,leave:h,join:a}=w;if(i&&[g,L,h,a].indexOf(o)>=0&&i!==this._joinRef())return;let _=this._onMessage(o,t,i);if(t&&!_)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(s=this.bindings.postgres_changes)===null||s===void 0||s.filter(r=>{var u,l,f;return((u=r.filter)===null||u===void 0?void 0:u.event)==="*"||((f=(l=r.filter)===null||l===void 0?void 0:l.event)===null||f===void 0?void 0:f.toLocaleLowerCase())===o}).map(r=>r.callback(_,i)):(n=this.bindings[o])===null||n===void 0||n.filter(r=>{var u,l,f,p,j,b;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in r){let d=r.id,E=(u=r.filter)===null||u===void 0?void 0:u.event;return d&&((l=t.ids)===null||l===void 0?void 0:l.includes(d))&&(E==="*"||E?.toLocaleLowerCase()===((f=t.data)===null||f===void 0?void 0:f.type.toLocaleLowerCase()))}else{let d=(j=(p=r?.filter)===null||p===void 0?void 0:p.event)===null||j===void 0?void 0:j.toLocaleLowerCase();return d==="*"||d===((b=t?.event)===null||b===void 0?void 0:b.toLocaleLowerCase())}else return r.type.toLocaleLowerCase()===o}).map(r=>{if(typeof _=="object"&&"ids"in _){let u=_.data,{schema:l,table:f,commit_timestamp:p,type:j,errors:b}=u;_=Object.assign(Object.assign({},{schema:l,table:f,commit_timestamp:p,eventType:j,new:{},old:{},errors:b}),this._getPayloadRecords(u))}r.callback(_,i)})}_isClosed(){return this.state===v.closed}_isJoined(){return this.state===v.joined}_isJoining(){return this.state===v.joining}_isLeaving(){return this.state===v.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,i){let s=e.toLocaleLowerCase(),n={type:s,filter:t,callback:i};return this.bindings[s]?this.bindings[s].push(n):this.bindings[s]=[n],this}_off(e,t){let i=e.toLocaleLowerCase();return this.bindings[i]=this.bindings[i].filter(s=>{var n;return!(((n=s.type)===null||n===void 0?void 0:n.toLocaleLowerCase())===i&&C.isEqual(s.filter,t))}),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(let i in e)if(e[i]!==t[i])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(w.close,{},e)}_onError(e){this._on(w.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=v.joining,this.joinPush.resend(e))}_getPayloadRecords(e){let t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=P.convertChangeData(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=P.convertChangeData(e.columns,e.old_record)),t}};export{T as REALTIME_LISTEN_TYPES,O as REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,R as REALTIME_SUBSCRIBE_STATES,C as default};
//# sourceMappingURL=RealtimeChannel.js.map