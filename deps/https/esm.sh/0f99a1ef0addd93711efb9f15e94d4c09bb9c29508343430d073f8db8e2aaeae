/* esm.sh - esbuild bundle(langchain@0.0.66/callbacks) deno production */
import __Process$ from "https://deno.land/std@0.177.0/node/process.ts";import{v4 as E}from"/v118/uuid@9.0.0/deno/uuid.mjs";var w=class{},i=class extends w{constructor(e){super(),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),e&&(this.ignoreLLM=e.ignoreLLM??this.ignoreLLM,this.ignoreChain=e.ignoreChain??this.ignoreChain,this.ignoreAgent=e.ignoreAgent??this.ignoreAgent)}copy(){return new this.constructor(this)}static fromMethods(e){class r extends i{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:E()}),Object.assign(this,e)}}return new r}};var y=class extends i{constructor(){super(),Object.defineProperty(this,"session",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"runMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"executionOrder",{enumerable:!0,configurable:!0,writable:!0,value:1})}async newSession(e){let r={start_time:Date.now(),name:e},t=await this.persistSession(r);return this.session=t,t}_addChildRun(e,r){if(r.type==="llm")e.child_llm_runs.push(r);else if(r.type==="chain")e.child_chain_runs.push(r);else if(r.type==="tool")e.child_tool_runs.push(r);else throw new Error("Invalid run type")}_startTrace(e){if(this.executionOrder+=1,e.parent_uuid){let r=this.runMap.get(e.parent_uuid);if(r)if(r.type==="tool"||r.type==="chain")this._addChildRun(r,e);else throw new Error("Caller run can only be a tool or chain");else throw new Error(`Caller run ${e.parent_uuid} not found`)}this.runMap.set(e.uuid,e)}async _endTrace(e){e.parent_uuid||(await this.persistRun(e),this.executionOrder=1),this.runMap.delete(e.uuid)}async handleLLMStart(e,r,t,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let a={uuid:t,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,prompts:r,session_id:this.session.id,execution_order:this.executionOrder,type:"llm"};this._startTrace(a)}async handleLLMEnd(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="llm")throw new Error("No LLM run to end.");let n=t;n.end_time=Date.now(),n.response=e,await this._endTrace(n)}async handleLLMError(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="llm")throw new Error("No LLM run to end.");let n=t;n.end_time=Date.now(),n.error=e.message,await this._endTrace(n)}async handleChainStart(e,r,t,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let a={uuid:t,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,inputs:r,session_id:this.session.id,execution_order:this.executionOrder,type:"chain",child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(a)}async handleChainEnd(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="chain")throw new Error("No chain run to end.");let n=t;n.end_time=Date.now(),n.outputs=e,await this._endTrace(n)}async handleChainError(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="chain")throw new Error("No chain run to end.");let n=t;n.end_time=Date.now(),n.error=e.message,await this._endTrace(n)}async handleToolStart(e,r,t,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let a={uuid:t,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,tool_input:r,session_id:this.session.id,execution_order:this.executionOrder,type:"tool",action:JSON.stringify(e),child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(a)}async handleToolEnd(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="tool")throw new Error("No tool run to end");let n=t;n.end_time=Date.now(),n.output=e,await this._endTrace(n)}async handleToolError(e,r){let t=this.runMap.get(r);if(!t||t?.type!=="tool")throw new Error("No tool run to end");let n=t;n.end_time=Date.now(),n.error=e.message,await this._endTrace(n)}},l=class extends y{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"endpoint",{enumerable:!0,configurable:!0,writable:!0,value:(typeof __Process$<"u"?__Process$.env?.LANGCHAIN_ENDPOINT:void 0)||"http://localhost:8000"}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:{"Content-Type":"application/json"}}),typeof __Process$<"u"&&__Process$.env?.LANGCHAIN_API_KEY&&(this.headers["x-api-key"]=__Process$.env?.LANGCHAIN_API_KEY)}async persistRun(e){let r;e.type==="llm"?r=`${this.endpoint}/llm-runs`:e.type==="chain"?r=`${this.endpoint}/chain-runs`:r=`${this.endpoint}/tool-runs`;let t=await fetch(r,{method:"POST",headers:this.headers,body:JSON.stringify(e)});t.ok||console.error(`Failed to persist run: ${t.status} ${t.statusText}`)}async persistSession(e){let r=`${this.endpoint}/sessions`,t=await fetch(r,{method:"POST",headers:this.headers,body:JSON.stringify(e)});return t.ok?{id:(await t.json()).id,...e}:(console.error(`Failed to persist session: ${t.status} ${t.statusText}, using default session.`),{id:1,...e})}async loadSession(e){let r=`${this.endpoint}/sessions?name=${e}`;return this._handleSessionResponse(r)}async loadDefaultSession(){let e=`${this.endpoint}/sessions?name=default`;return this._handleSessionResponse(e)}async _handleSessionResponse(e){let r=await fetch(e,{method:"GET",headers:this.headers}),t;if(!r.ok)return console.error(`Failed to load session: ${r.status} ${r.statusText}`),t={id:1,start_time:Date.now()},this.session=t,t;let n=await r.json();return n.length===0?(t={id:1,start_time:Date.now()},this.session=t,t):([t]=n,this.session=t,t)}copy(){if(this.executionOrder===1){let e=new l;return e.session=this.session,e.runMap=new Map(this.runMap),e.executionOrder=this.executionOrder,e}return this}};async function g(s){let e=new l;return s?await e.loadSession(s):await e.loadDefaultSession(),e}import{v4 as c}from"/v118/uuid@9.0.0/deno/uuid.mjs";var h=class extends i{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"console_callback_handler"})}handleLLMStart(e,r,t){console.log(`Starting LLM ${t} with name ${e.name} with prompts: ${r.join(", ")}
`)}handleLLMError(e,r){console.log(`LLM ${r} errored: ${e}
`)}handleLLMEnd(e,r){console.log(`LLM ${r} finished: ${JSON.stringify(e)}
`)}handleChainStart(e){console.log(`Entering new ${e.name} chain...`)}handleChainEnd(e){console.log("Finished chain.")}handleAgentAction(e){console.log(e.log)}handleToolEnd(e){console.log(e)}handleText(e){console.log(e)}handleAgentEnd(e){console.log(e.log)}};var b=class{setHandler(e){return this.setHandlers([e])}},u=class{constructor(e,r,t,n){Object.defineProperty(this,"runId",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:n})}async handleText(e){await Promise.all(this.handlers.map(async r=>{try{await r.handleText?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleText: ${t}`)}}))}},p=class extends u{async handleLLMNewToken(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreLLM)try{await r.handleLLMNewToken?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleLLMNewToken: ${t}`)}}))}async handleLLMError(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreLLM)try{await r.handleLLMError?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleLLMError: ${t}`)}}))}async handleLLMEnd(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreLLM)try{await r.handleLLMEnd?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleLLMEnd: ${t}`)}}))}},f=class extends u{getChild(){let e=new o(this.runId);return e.setHandlers(this.inheritableHandlers),e}async handleChainError(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreChain)try{await r.handleChainError?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleChainError: ${t}`)}}))}async handleChainEnd(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreChain)try{await r.handleChainEnd?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleChainEnd: ${t}`)}}))}async handleAgentAction(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreAgent)try{await r.handleAgentAction?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleAgentAction: ${t}`)}}))}async handleAgentEnd(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreAgent)try{await r.handleAgentEnd?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleAgentEnd: ${t}`)}}))}},m=class extends u{getChild(){let e=new o(this.runId);return e.setHandlers(this.inheritableHandlers),e}async handleToolError(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreAgent)try{await r.handleToolError?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleToolError: ${t}`)}}))}async handleToolEnd(e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreAgent)try{await r.handleToolEnd?.(e,this.runId,this._parentRunId)}catch(t){console.error(`Error in handler ${r.constructor.name}, handleToolEnd: ${t}`)}}))}},o=class extends b{constructor(e){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"callback_manager"}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=[],this.inheritableHandlers=[],this._parentRunId=e}async handleLLMStart(e,r,t=c()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreLLM)try{await n.handleLLMStart?.(e,r,t,this._parentRunId)}catch(a){console.error(`Error in handler ${n.constructor.name}, handleLLMStart: ${a}`)}})),new p(t,this.handlers,this.inheritableHandlers,this._parentRunId)}async handleChainStart(e,r,t=c()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreChain)try{await n.handleChainStart?.(e,r,t,this._parentRunId)}catch(a){console.error(`Error in handler ${n.constructor.name}, handleChainStart: ${a}`)}})),new f(t,this.handlers,this.inheritableHandlers,this._parentRunId)}async handleToolStart(e,r,t=c()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreAgent)try{await n.handleToolStart?.(e,r,t,this._parentRunId)}catch(a){console.error(`Error in handler ${n.constructor.name}, handleToolStart: ${a}`)}})),new m(t,this.handlers,this.inheritableHandlers,this._parentRunId)}addHandler(e,r=!0){this.handlers.push(e),r&&this.inheritableHandlers.push(e)}removeHandler(e){this.handlers=this.handlers.filter(r=>r!==e),this.inheritableHandlers=this.inheritableHandlers.filter(r=>r!==e)}setHandlers(e,r=!0){this.handlers=[],this.inheritableHandlers=[];for(let t of e)this.addHandler(t,r)}copy(e=[],r=!0){let t=new o(this._parentRunId);t.setHandlers([...this.handlers].map(n=>n.copy()));for(let n of e)t.addHandler(n.copy(),r);return t}static fromHandlers(e){class r extends i{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:c()}),Object.assign(this,e)}}let t=new this;return t.addHandler(new r),t}static async configure(e,r,t){let n;(e||r)&&(Array.isArray(e)||!e?(n=new o,n.setHandlers(e?.map(L)??[],!0)):n=e,n=n.copy(Array.isArray(r)?r.map(L):r?.handlers,!1));let a=typeof __Process$<"u"?__Process$.env?.LANGCHAIN_TRACING!==void 0:!1;if(t?.verbose||a){n||(n=new o);let _=new h;if(t?.verbose&&!n.handlers.some(d=>d.name===_.name)&&n.addHandler(_,!0),a&&!n.handlers.some(d=>d.name==="langchain_tracer")){let d=typeof __Process$<"u"?__Process$.env?.LANGCHAIN_SESSION:void 0;n.addHandler(await g(d),!0)}}return n}};function L(s){return"name"in s?s:i.fromMethods(s)}export{i as BaseCallbackHandler,o as CallbackManager,f as CallbackManagerForChainRun,p as CallbackManagerForLLMRun,m as CallbackManagerForToolRun,h as ConsoleCallbackHandler,l as LangChainTracer,g as getTracingCallbackHandler};
//# sourceMappingURL=callbacks.js.map