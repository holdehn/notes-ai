/* esm.sh - esbuild bundle(langchain@0.0.73/vectorstores) deno production */
var D=class{};var C=class extends D{constructor(e){super(),Object.defineProperty(this,"vectorStore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"k",{enumerable:!0,configurable:!0,writable:!0,value:4}),Object.defineProperty(this,"filter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.vectorStore=e.vectorStore,this.k=e.k??this.k,this.filter=e.filter}async getRelevantDocuments(e){return await this.vectorStore.similaritySearch(e,this.k,this.filter)}async addDocuments(e){await this.vectorStore.addDocuments(e)}},d=class{constructor(e,t){Object.defineProperty(this,"embeddings",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.embeddings=e}async similaritySearch(e,t=4,r=void 0){return(await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e),t,r)).map(i=>i[0])}async similaritySearchWithScore(e,t=4,r=void 0){return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e),t,r)}static fromTexts(e,t,r,s){throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug")}static fromDocuments(e,t,r){throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug")}asRetriever(e,t){return new C({vectorStore:this,k:e,filter:t})}},y=class extends d{static load(e,t){throw new Error("Not implemented")}};var u=class{constructor(e){Object.defineProperty(this,"pageContent",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.pageContent=e.pageContent?e.pageContent.toString():this.pageContent,this.metadata=e.metadata??{}}};var g=class{};var p=class extends g{constructor(e){super(),Object.defineProperty(this,"_docs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._docs=e??new Map}get count(){return this._docs.size}search(e){return this._docs.get(e)??`ID ${e} not found.`}add(e){let t=[...this._docs.keys()],r=Object.keys(e).filter(s=>t.includes(s));if(r.length>0)throw new Error(`Tried to add ids that already exist: ${r}`);for(let[s,i]of Object.entries(e))this._docs.set(s,i)}};var f=class extends y{constructor(e,t){super(e,t),Object.defineProperty(this,"_index",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docstore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"args",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._index=t.index,this.args=t,this.embeddings=e,this.docstore=t?.docstore??new p}async addDocuments(e){let t=e.map(({pageContent:r})=>r);return this.addVectors(await this.embeddings.embedDocuments(t),e)}static async getHierarchicalNSW(e){let{HierarchicalNSW:t}=await f.imports();if(!e.space)throw new Error("hnswlib-node requires a space argument");if(e.numDimensions===void 0)throw new Error("hnswlib-node requires a numDimensions argument");return new t(e.space,e.numDimensions)}async initIndex(e){this._index||(this.args.numDimensions===void 0&&(this.args.numDimensions=e[0].length),this.index=await f.getHierarchicalNSW(this.args)),this.index.getCurrentCount()||this.index.initIndex(e.length)}get index(){if(!this._index)throw new Error("Vector store not initialised yet. Try calling `addTexts` first.");return this._index}set index(e){this._index=e}async addVectors(e,t){if(e.length===0)return;if(await this.initIndex(e),e.length!==t.length)throw new Error("Vectors and metadatas must have the same length");if(e[0].length!==this.args.numDimensions)throw new Error(`Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`);let r=this.index.getMaxElements(),s=this.index.getCurrentCount()+e.length;s>r&&this.index.resizeIndex(s);let i=this.docstore.count;for(let n=0;n<e.length;n+=1)this.index.addPoint(e[n],i+n),this.docstore.add({[i+n]:t[n]})}async similaritySearchVectorWithScore(e,t,r){if(this.args.numDimensions&&!this._index&&await this.initIndex([[]]),e.length!==this.args.numDimensions)throw new Error(`Query vector must have the same length as the number of dimensions (${this.args.numDimensions})`);if(t>this.index.getCurrentCount()){let n=this.index.getCurrentCount();console.warn(`k (${t}) is greater than the number of elements in the index (${n}), setting k to ${n}`),t=n}let s=n=>{if(!r)return!0;let o=this.docstore.search(String(n));return typeof o!="string"?r(o):!1},i=this.index.searchKnn(e,t,r?s:void 0);return i.neighbors.map((n,o)=>[this.docstore.search(String(n)),i.distances[o]])}async save(e){let t=await import("https://deno.land/std@0.177.0/node/fs/promises.ts"),r=await import("https://deno.land/std@0.177.0/node/path.ts");await t.mkdir(e,{recursive:!0}),await Promise.all([this.index.writeIndex(r.join(e,"hnswlib.index")),await t.writeFile(r.join(e,"args.json"),JSON.stringify(this.args)),await t.writeFile(r.join(e,"docstore.json"),JSON.stringify(Array.from(this.docstore._docs.entries())))])}static async load(e,t){let r=await import("https://deno.land/std@0.177.0/node/fs/promises.ts"),s=await import("https://deno.land/std@0.177.0/node/path.ts"),i=JSON.parse(await r.readFile(s.join(e,"args.json"),"utf8")),n=await f.getHierarchicalNSW(i),[o]=await Promise.all([r.readFile(s.join(e,"docstore.json"),"utf8").then(JSON.parse),n.readIndex(s.join(e,"hnswlib.index"))]);return i.docstore=new p(new Map(o)),i.index=n,new f(t,i)}static async fromTexts(e,t,r,s){let i=[];for(let n=0;n<e.length;n+=1){let o=Array.isArray(t)?t[n]:t,a=new u({pageContent:e[n],metadata:o});i.push(a)}return f.fromDocuments(i,r,s)}static async fromDocuments(e,t,r){let s={docstore:r?.docstore,space:"cosine"},i=new this(t,s);return await i.addDocuments(e),i}static async imports(){try{let{default:{HierarchicalNSW:e}}=await import("/v124/hnswlib-node@1.4.2/deno/hnswlib-node.mjs");return{HierarchicalNSW:e}}catch{throw new Error("Please install hnswlib-node as a dependency with, e.g. `npm install -S hnswlib-node`")}}};import*as P from"/v124/uuid@9.0.0/deno/uuid.mjs";var b=class extends d{constructor(e,t){super(e,t),Object.defineProperty(this,"index",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"collection",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"collectionName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"numDimensions",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.numDimensions=t.numDimensions,this.embeddings=e,this.collectionName=_(t.collectionName),"index"in t?this.index=t.index:"url"in t&&(this.url=t.url||"http://localhost:8000")}async addDocuments(e){let t=e.map(({pageContent:r})=>r);await this.addVectors(await this.embeddings.embedDocuments(t),e)}async ensureCollection(){if(!this.collection){if(!this.index){let{ChromaClient:e}=await b.imports();this.index=new e(this.url)}this.collection=await this.index.getOrCreateCollection(this.collectionName)}return this.collection}async addVectors(e,t){if(e.length===0)return;if(this.numDimensions===void 0&&(this.numDimensions=e[0].length),e.length!==t.length)throw new Error("Vectors and metadatas must have the same length");if(e[0].length!==this.numDimensions)throw new Error(`Vectors must have the same length as the number of dimensions (${this.numDimensions})`);let r=await this.ensureCollection(),s=await r.count();await r.add(Array.from({length:e.length},(i,n)=>(s+n).toString()),e,t.map(({metadata:i})=>i),t.map(({pageContent:i})=>i))}async similaritySearchVectorWithScore(e,t){let s=await(await this.ensureCollection()).query(e,t),{ids:i,distances:n,documents:o,metadatas:a}=s;if(!i||!n||!o||!a)return[];let[c]=i,[l]=n,[S]=o,[j]=a,O=[];for(let w=0;w<c.length;w+=1)O.push([new u({pageContent:S[w],metadata:j[w]}),l[w]]);return O}static async fromTexts(e,t,r,s){let i=[];for(let n=0;n<e.length;n+=1){let o=Array.isArray(t)?t[n]:t,a=new u({pageContent:e[n],metadata:o});i.push(a)}return b.fromDocuments(i,r,s)}static async fromDocuments(e,t,r){let s=new this(t,r);return await s.addDocuments(e),s}static async fromExistingCollection(e,t){let r=new this(e,t);return await r.ensureCollection(),r}static async imports(){try{let{ChromaClient:e}=await import("/v124/chromadb@1.5.2/deno/chromadb.mjs");return{ChromaClient:e}}catch{throw new Error("Please install chromadb as a dependency with, e.g. `npm install -S chromadb`")}}};function _(h){return h||`langchain-${P.v4()}`}import*as E from"/v124/uuid@9.0.0/deno/uuid.mjs";import q from"/v124/flat@5.0.2/deno/flat.mjs";var x=class extends d{constructor(e,t){super(e,t),Object.defineProperty(this,"textKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"namespace",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"pineconeIndex",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"filter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.embeddings=e,this.namespace=t.namespace,this.pineconeIndex=t.pineconeIndex,this.textKey=t.textKey??"text",this.filter=t.filter}async addDocuments(e,t){let r=e.map(({pageContent:s})=>s);return this.addVectors(await this.embeddings.embedDocuments(r),e,t)}async addVectors(e,t,r){let s=r??t.map(()=>E.v4()),i=e.map((o,a)=>{let c=q({...t[a].metadata,[this.textKey]:t[a].pageContent});for(let l of Object.keys(c))(c[l]==null||typeof c[l]=="object"&&Object.keys(c[l]).length===0)&&delete c[l];return{id:s[a],metadata:c,values:o}}),n=50;for(let o=0;o<i.length;o+=n){let a=i.slice(o,o+n);await this.pineconeIndex.upsert({upsertRequest:{vectors:a,namespace:this.namespace}})}}async similaritySearchVectorWithScore(e,t,r){if(r&&this.filter)throw new Error("cannot provide both `filter` and `this.filter`");let s=r??this.filter,i=await this.pineconeIndex.query({queryRequest:{includeMetadata:!0,namespace:this.namespace,topK:t,vector:e,filter:s}}),n=[];if(i.matches)for(let o of i.matches){let{[this.textKey]:a,...c}=o.metadata??{};o.score&&n.push([new u({metadata:c,pageContent:a}),o.score])}return n}static async fromTexts(e,t,r,s){let i=[];for(let o=0;o<e.length;o+=1){let a=Array.isArray(t)?t[o]:t,c=new u({pageContent:e[o],metadata:a});i.push(c)}let n={pineconeIndex:"pineconeIndex"in s?s.pineconeIndex:s.pineconeClient,textKey:s.textKey,namespace:s.namespace};return x.fromDocuments(i,r,n)}static async fromDocuments(e,t,r){let s=r;s.textKey=r.textKey??"text";let i=new this(t,s);return await i.addDocuments(e),i}static async fromExistingIndex(e,t){return new this(e,t)}};var v=class extends d{constructor(e,t){super(e,t),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tableName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queryName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"filter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.client=t.client,this.tableName=t.tableName||"documents",this.queryName=t.queryName||"match_documents",this.filter=t.filter}async addDocuments(e){let t=e.map(({pageContent:r})=>r);return this.addVectors(await this.embeddings.embedDocuments(t),e)}async addVectors(e,t){let r=e.map((i,n)=>({content:t[n].pageContent,embedding:i,metadata:t[n].metadata})),s=500;for(let i=0;i<r.length;i+=s){let n=r.slice(i,i+s),o=await this.client.from(this.tableName).insert(n);if(o.error)throw new Error(`Error inserting: ${o.error.message} ${o.status} ${o.statusText}`)}}async similaritySearchVectorWithScore(e,t,r){if(r&&this.filter)throw new Error("cannot provide both `filter` and `this.filter`");let i={filter:r??this.filter,query_embedding:e,match_count:t},{data:n,error:o}=await this.client.rpc(this.queryName,i);if(o)throw new Error(`Error searching for documents: ${o.code} ${o.message} ${o.details}`);return n.map(c=>[new u({metadata:c.metadata,pageContent:c.content}),c.similarity])}static async fromTexts(e,t,r,s){let i=[];for(let n=0;n<e.length;n+=1){let o=Array.isArray(t)?t[n]:t,a=new u({pageContent:e[n],metadata:o});i.push(a)}return v.fromDocuments(i,r,s)}static async fromDocuments(e,t,r){let s=new this(t,r);return await s.addDocuments(e),s}static async fromExistingIndex(e,t){return new this(e,t)}};var $=Symbol("id"),I=Symbol("content"),m=class extends d{constructor(e,t){super(e,{}),Object.defineProperty(this,"tableSql",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"vectorColumnSql",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"selectSql",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"idColumn",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"contentColumn",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"db",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"Prisma",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.Prisma=t.prisma,this.db=t.db;let r=Object.entries(t.columns),s=r.find(n=>n[1]===$)?.[0],i=r.find(n=>n[1]===I)?.[0];if(s==null)throw new Error("Missing ID column");if(i==null)throw new Error("Missing content column");this.idColumn=s,this.contentColumn=i,this.tableSql=this.Prisma.raw(`"${t.tableName}"`),this.vectorColumnSql=this.Prisma.raw(`"${t.vectorColumnName}"`),this.selectSql=this.Prisma.raw(r.map(([n,o])=>o&&n||null).filter(n=>!!n).map(n=>`"${n}"`).join(", "))}static withModel(e){function t(i,n){return new m(i,{...n,db:e})}async function r(i,n,o,a){let c=[];for(let l=0;l<i.length;l+=1){let S=Array.isArray(n)?n[l]:n,j=new u({pageContent:i[l],metadata:S});c.push(j)}return m.fromDocuments(c,o,{...a,db:e})}async function s(i,n,o){let a=new m(n,{...o,db:e});return await a.addDocuments(i),a}return{create:t,fromTexts:r,fromDocuments:s}}async addModels(e){return this.addDocuments(e.map(t=>{let r=t[this.contentColumn];if(typeof r!="string")throw new Error("Content column must be a string");return new u({pageContent:r,metadata:t})}))}async addDocuments(e){let t=e.map(({pageContent:r})=>r);return this.addVectors(await this.embeddings.embedDocuments(t),e)}async addVectors(e,t){let r=this.Prisma.raw(`"${this.idColumn}"`);await this.db.$transaction(e.map((s,i)=>this.db.$executeRaw`
          UPDATE ${this.tableSql}
          SET ${this.vectorColumnSql} = ${`[${s.join(",")}]`}::vector
          WHERE ${r} = ${t[i].metadata[this.idColumn]}
        `))}async similaritySearch(e,t=4){return(await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e),t)).map(s=>s[0])}async similaritySearchVectorWithScore(e,t){let r=`[${e.join(",")}]`,s=await this.db.$queryRaw`
      SELECT ${this.selectSql}, ${this.vectorColumnSql} <=> ${r}::vector as "_distance" 
      FROM ${this.tableSql}
      ORDER BY "_distance" ASC
      LIMIT ${t};
    `,i=[];for(let n of s)n._distance!=null&&n[this.contentColumn]!=null&&i.push([new u({pageContent:n[this.contentColumn],metadata:n}),n._distance]);return i}static async fromTexts(e,t,r,s){let i=[];for(let n=0;n<e.length;n+=1){let o=Array.isArray(t)?t[n]:t,a=new u({pageContent:e[n],metadata:o});i.push(a)}return m.fromDocuments(i,r,s)}static async fromDocuments(e,t,r){let s=new m(t,r);return await s.addDocuments(e),s}};Object.defineProperty(m,"IdColumn",{enumerable:!0,configurable:!0,writable:!0,value:$});Object.defineProperty(m,"ContentColumn",{enumerable:!0,configurable:!0,writable:!0,value:I});export{b as Chroma,f as HNSWLib,x as PineconeStore,m as PrismaVectorStore,y as SaveableVectorStore,v as SupabaseVectorStore,d as VectorStore};
//# sourceMappingURL=vectorstores.js.map