/* esm.sh - esbuild bundle(ml-kmeans@6.0.0) deno production */
import{squaredEuclidean as P}from"/v120/ml-distance-euclidean@2.0.0/deno/ml-distance-euclidean.mjs";import V from"/v120/ml-nearest-vector@2.0.1/deno/ml-nearest-vector.mjs";function k(n,r){let t=new Array(n.length);for(let e=0;e<n.length;++e)for(let i=e;i<n.length;++i){t[e]||(t[e]=new Array(n.length)),t[i]||(t[i]=new Array(n.length));let l=r(n[e],n[i]);t[e][i]=l,t[i][e]=l}return t}function w(n,r,t,e){for(let i=0;i<n.length;i++)t[i]=V(r,n[i],{distanceFunction:e});return t}function v(n,r,t,e){let i=r[0].length,l=new Array(e),c=new Array(e);for(let o=0;o<e;o++){l[o]=new Array(i),c[o]=0;for(let s=0;s<i;s++)l[o][s]=0}for(let o=0;o<r.length;o++){c[t[o]]++;for(let s=0;s<i;s++)l[t[o]][s]+=r[o][s]}for(let o=0;o<e;o++)for(let s=0;s<i;s++)c[o]?l[o][s]/=c[o]:l[o][s]=n[o][s];return l}function R(n,r,t,e){for(let i=0;i<n.length;i++)if(t(n[i],r[i])>e)return!1;return!0}var g=class{constructor(r,t,e,i,l){this.clusters=r,this.centroids=t,this.converged=e,this.iterations=i,this.distance=l}nearest(r){let t=new Array(r.length);return w(r,this.centroids,t,this.distance)}computeInformation(r){let t=this.centroids.map(e=>({centroid:e,error:0,size:0}));for(let e=0;e<r.length;e++)t[this.clusters[e]].error+=this.distance(r[e],this.centroids[this.clusters[e]]),t[this.clusters[e]].size++;for(let e=0;e<this.centroids.length;e++){let i=t[e].error;t[e].size&&i!==-1?i/=t[e].size:t[e].error=-1}return t}};function E(n,r){throw new Error(`${r}: "${String(n)}"`)}function p(n,r){if(r<=0||r>n.length||!Number.isInteger(r))throw new Error("K should be a positive integer smaller than the number of points")}import{squaredEuclidean as M}from"/v120/ml-distance-euclidean@2.0.0/deno/ml-distance-euclidean.mjs";import{Matrix as d}from"/v120/ml-matrix@6.10.4/deno/ml-matrix.mjs";import x from"/v120/ml-random@0.5.0/deno/ml-random.mjs";function q(n,r,t){return new x(t).choice(n,{size:r})}function F(n,r,t,e){let i=new x(e),l=new Array(r);if(l[0]=Math.floor(i.random()*n.length),r>1){let c={dist:-1,index:-1};for(let o=0;o<n.length;++o)t[l[0]][o]>c.dist&&(c.dist=t[l[0]][o],c.index=o);if(l[1]=c.index,r>2)for(let o=2;o<r;++o){let s={dist:-1,index:-1};for(let a=0;a<n.length;++a){let u={dist:Number.MAX_VALUE,index:-1};for(let m=0;m<o;++m)t[m][a]<u.dist&&!l.includes(a)&&(u={dist:t[m][a],index:a});u.dist!==Number.MAX_VALUE&&u.dist>s.dist&&(s={...u})}l[o]=s.index}}return l.map(c=>n[c])}function N(n,r,t={}){let e=new d(n),i=e.rows,l=new x(t.seed),c=[],o=t.localTrials||2+Math.floor(Math.log(r)),s=l.randInt(i);c.push(e.getRow(s));let a=new d(1,e.rows);for(let f=0;f<e.rows;f++)a.set(0,f,M(e.getRow(f),c[0]));let u=[S(a.getRow(0))],m=1/u[0][i-1],b=d.mul(a,m);for(let f=1;f<r;f++){let A=l.choice(i,{replace:!0,size:o,probabilities:b.getRow(0)}),O=e.selection(A,_(e.columns)),T=X(O,e),y=1/0,C=1/0,D=a;for(let h=0;h<o;h++){let I=d.min(a,[T.getRow(h)]),z=I.sum();z<C&&(y=A[h],C=z,D=I)}c[f]=e.getRow(y),a=D,u=[S(a.getRow(0))],b=d.mul(a,1/u[0][i-1])}return c}function X(n,r){let t=new d(n.rows,r.rows);for(let e=0;e<n.rows;e++)for(let i=0;i<r.rows;i++)t.set(e,i,M(n.getRow(e),r.getRow(i)));return t}function _(n){let r=[];for(let t=0;t<n;t++)r.push(t);return r}function S(n){let r=[n[0]];for(let t=1;t<n.length;t++)r[t]=r[t-1]+n[t];return r}var $={maxIterations:100,tolerance:1e-6,initialization:"kmeans++",distanceFunction:P};function U(n,r,t,e,i,l){t=w(r,n,t,i.distanceFunction);let c=v(n,r,t,e),o=R(c,n,i.distanceFunction,i.tolerance);return new g(t,c,o,l,i.distanceFunction)}function*oe(n,r,t){let e=L(t);p(n,r);let i=j(n,r,e),l=new Array(n.length),c=!1,o=0,s;for(;!c&&o<e.maxIterations;)s=U(i,n,l,r,e,++o),yield s,c=s.converged,i=s.centroids}function se(n,r,t){let e=L(t);p(n,r);let i=j(n,r,e);e.maxIterations===0&&(e.maxIterations=Number.MAX_VALUE);let l=new Array(n.length),c=!1,o=0,s;for(;!c&&o<e.maxIterations;)s=U(i,n,l,r,e,++o),c=s.converged,i=s.centroids;if(!s)throw new Error("unreachable: no kmeans step executed");return s}function j(n,r,t){let e;if(Array.isArray(t.initialization)){if(t.initialization.length!==r)throw new Error("The initial centers should have the same length as K");e=t.initialization}else switch(t.initialization){case"kmeans++":e=N(n,r,t);break;case"random":e=q(n,r,t.seed);break;case"mostDistant":e=F(n,r,k(n,t.distanceFunction),t.seed);break;default:E(t.initialization,"Unknown initialization method")}return e}function L(n){return{...$,...n}}export{se as kmeans,oe as kmeansGenerator};
//# sourceMappingURL=ml-kmeans.mjs.map