/* esm.sh - esbuild bundle(langchainplus-sdk@0.0.11) deno production */
import __Process$ from "https://deno.land/std@0.177.1/node/process.ts";import*as v from"/v126/uuid@9.0.0/deno/uuid.mjs";import E from"/v126/p-retry@4.6.2/deno/p-retry.mjs";import b from"/v126/p-queue@6.6.2/deno/p-queue.mjs";var $=[400,401,403,404,405,406,407,408,409],m=class{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6;let t="default"in b?b.default:b;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add(()=>E(()=>e(...t).catch(r=>{throw r instanceof Error?r:new Error(r)}),{onFailedAttempt(r){if(r.message.startsWith("Cancel")||r.message.startsWith("TimeoutError")||r.message.startsWith("AbortError")||r?.code==="ECONNABORTED")throw r;let i=r?.response?.status;if(i&&$.includes(+i))throw r},retries:this.maxRetries,randomize:!0}),{throwOnTimeout:!0})}callWithOptions(e,t,...r){return e.signal?Promise.race([this.call(t,...r),new Promise((i,a)=>{e.signal?.addEventListener("abort",()=>{a(new Error("AbortError"))})})]):this.call(t,...r)}fetch(...e){return this.call(()=>fetch(...e).then(t=>t.ok?t:Promise.reject(t)))}};var j=()=>typeof document<"u"&&typeof window.document<"u",P=()=>typeof globalThis=="object"&&globalThis.constructor&&globalThis.constructor.name==="DedicatedWorkerGlobalScope",S=()=>typeof document<"u"&&window.name==="nodejs"||typeof navigator<"u"&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom")),g=()=>typeof Deno<"u",O=()=>typeof __Process$<"u"&&typeof __Process$.versions<"u"&&typeof __Process$.versions.node<"u"&&!g(),A=()=>{let o;return j()?o="browser":O()?o="node":P()?o="webworker":S()?o="jsdom":g()?o="deno":o="other",o},y;async function w(){return y===void 0&&(y={library:"langchainplus-sdk",runtime:A()}),y}function d(o){try{return typeof __Process$<"u"?__Process$.env?.[o]:void 0}catch{return}}var T=o=>{let t=o.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return t==="localhost"||t==="127.0.0.1"||t==="::1"},_=async(o,e)=>{let t=await o.text();if(!o.ok)throw new Error(`Failed to ${e}: ${o.status} ${o.statusText} ${t}`)},c=class{constructor(e={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=c.getDefaultClientConfig();this.apiUrl=e.apiUrl??t.apiUrl,this.apiKey=e.apiKey??t.apiKey,this.validateApiKeyIfHosted(),this.timeout_ms=e.timeout_ms??4e3,this.caller=new m(e.callerOptions??{})}static getDefaultClientConfig(){return{apiUrl:d("LANGCHAIN_ENDPOINT")??"http://localhost:1984",apiKey:d("LANGCHAIN_API_KEY")}}validateApiKeyIfHosted(){if(!T(this.apiUrl)&&!this.apiKey)throw new Error("API key must be provided when using hosted LangChain+ API")}get headers(){let e={};return this.apiKey&&(e["x-api-key"]=`${this.apiKey}`),e}async _get(e,t){let r=t?.toString()??"",i=`${this.apiUrl}${e}?${r}`,a=await this.caller.call(fetch,i,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to fetch ${e}: ${a.status} ${a.statusText}`);return a.json()}async createRun(e){let t={...this.headers,"Content-Type":"application/json"},r=e.extra??{},i=await w(),a={...e,extra:{...e.extra,runtime:{...i,...r.runtime}}},s=await this.caller.call(fetch,`${this.apiUrl}/runs`,{method:"POST",headers:t,body:JSON.stringify(a),signal:AbortSignal.timeout(this.timeout_ms)});await _(s,"create run")}async updateRun(e,t){let r={...this.headers,"Content-Type":"application/json"},i=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}`,{method:"PATCH",headers:r,body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});await _(i,"update run")}async readRun(e){return await this._get(`/runs/${e}`)}async listRuns({sessionId:e,sessionName:t,executionOrder:r,runType:i,error:a}){let s=new URLSearchParams,n=e;if(t){if(e)throw new Error("Only one of sessionId or sessionName may be given");n=(await this.readSession({sessionName:t})).id}return n&&s.append("session",n),r&&s.append("execution_order",r.toString()),i&&s.append("run_type",i),a!==void 0&&s.append("error",a.toString()),this._get("/runs",s)}async createSession({sessionName:e,sessionExtra:t}){let r=`${this.apiUrl}/sessions?upsert=true`,i={name:e,extra:t},a=await this.caller.call(fetch,r,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms)}),s=await a.json();if(!a.ok)throw new Error(`Failed to create session ${e}: ${a.status} ${a.statusText}`);return s}async readSession({sessionId:e,sessionName:t}){let r="/sessions",i=new URLSearchParams;if(e!==void 0&&t!==void 0)throw new Error("Must provide either sessionName or sessionId, not both");if(e!==void 0)r+=`/${e}`;else if(t!==void 0)i.append("name",t);else throw new Error("Must provide sessionName or sessionId");let a=await this._get(r,i),s;if(Array.isArray(a)){if(a.length===0)throw new Error(`Session[id=${e}, name=${t}] not found`);s=a[0]}else s=a;return s}async listSessions(){return this._get("/sessions")}async deleteSession({sessionId:e,sessionName:t}){let r;if(e===void 0&&t===void 0)throw new Error("Must provide sessionName or sessionId");if(e!==void 0&&t!==void 0)throw new Error("Must provide either sessionName or sessionId, not both");e===void 0?r=(await this.readSession({sessionName:t})).id:r=e;let i=await this.caller.call(fetch,`${this.apiUrl}/sessions/${r}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await _(i,`delete session ${r} (${t})`)}async uploadCsv({csvFile:e,fileName:t,inputKeys:r,outputKeys:i,description:a}){let s=`${this.apiUrl}/datasets/upload`,n=new FormData;n.append("file",e,t),n.append("input_keys",r.join(",")),n.append("output_keys",i.join(",")),a&&n.append("description",a);let u=await this.caller.call(fetch,s,{method:"POST",headers:this.headers,body:n,signal:AbortSignal.timeout(this.timeout_ms)});if(!u.ok){let p=await u.json();throw p.detail&&p.detail.includes("already exists")?new Error(`Dataset ${t} already exists`):new Error(`Failed to upload CSV: ${u.status} ${u.statusText}`)}return await u.json()}async createDataset(e,{description:t}={}){let r=await this.caller.call(fetch,`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify({name:e,description:t}),signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok){let a=await r.json();throw a.detail&&a.detail.includes("already exists")?new Error(`Dataset ${e} already exists`):new Error(`Failed to create dataset ${r.status} ${r.statusText}`)}return await r.json()}async readDataset({datasetId:e,datasetName:t}){let r="/datasets",i=new URLSearchParams({limit:"1"});if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)r+=`/${e}`;else if(t!==void 0)i.append("name",t);else throw new Error("Must provide datasetName or datasetId");let a=await this._get(r,i),s;if(Array.isArray(a)){if(a.length===0)throw new Error(`Dataset[id=${e}, name=${t}] not found`);s=a[0]}else s=a;return s}async listDatasets({limit:e=100}={}){let t="/datasets",r=new URLSearchParams({limit:e.toString()}),i=await this._get(t,r);if(!Array.isArray(i))throw new Error(`Expected ${t} to return an array, but got ${i}`);return i}async deleteDataset({datasetId:e,datasetName:t}){let r="/datasets",i=e;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(t!==void 0&&(i=(await this.readDataset({datasetName:t})).id),i!==void 0)r+=`/${i}`;else throw new Error("Must provide datasetName or datasetId");let a=await this.caller.call(fetch,this.apiUrl+r,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to delete ${r}: ${a.status} ${a.statusText}`);return await a.json()}async createExample(e,t,{datasetId:r,datasetName:i,createdAt:a}){let s=r;if(s===void 0&&i===void 0)throw new Error("Must provide either datasetName or datasetId");if(s!==void 0&&i!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");s===void 0&&(s=(await this.readDataset({datasetName:i})).id);let u={dataset_id:s,inputs:e,outputs:t,created_at:(a||new Date).toISOString()},l=await this.caller.call(fetch,`${this.apiUrl}/examples`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(u),signal:AbortSignal.timeout(this.timeout_ms)});if(!l.ok)throw new Error(`Failed to create example: ${l.status} ${l.statusText}`);return await l.json()}async readExample(e){let t=`/examples/${e}`;return await this._get(t)}async listExamples({datasetId:e,datasetName:t}={}){let r;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)r=e;else if(t!==void 0)r=(await this.readDataset({datasetName:t})).id;else throw new Error("Must provide a datasetName or datasetId");let i=await this._get("/examples",new URLSearchParams({dataset:r}));if(!Array.isArray(i))throw new Error(`Expected /examples to return an array, but got ${i}`);return i}async deleteExample(e){let t=`/examples/${e}`,r=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to delete ${t}: ${r.status} ${r.statusText}`);return await r.json()}async updateExample(e,t){let r=await this.caller.call(fetch,`${this.apiUrl}/examples/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to update example ${e}: ${r.status} ${r.statusText}`);return await r.json()}async evaluateRun(e,t,{sourceInfo:r}={}){let i;if(typeof e=="string")i=await this.readRun(e);else if(typeof e=="object"&&"id"in e)i=e;else throw new Error(`Invalid run type: ${typeof e}`);let a;i.reference_example_id!==null&&i.reference_example_id!==void 0&&(a=await this.readExample(i.reference_example_id));let s=await t.evaluateRun(i,a),n=r??{};return s.evaluatorInfo&&(n={...n,...s.evaluatorInfo}),await this.createFeedback(i.id,s.key,{score:s.score,value:s.value,comment:s.comment,correction:s.correction,sourceInfo:n,feedbackSourceType:"MODEL"})}async createFeedback(e,t,{score:r,value:i,correction:a,comment:s,sourceInfo:n,feedbackSourceType:u="API"}){let l;if(u==="API")l={type:"api",metadata:n??{}};else if(u==="MODEL")l={type:"model",metadata:n??{}};else throw new Error(`Unknown feedback source type ${u}`);let p={id:v.v4(),run_id:e,key:t,score:r,value:i,correction:a,comment:s,feedback_source:l},f=await this.caller.call(fetch,`${this.apiUrl}/feedback`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(p),signal:AbortSignal.timeout(this.timeout_ms)});if(!f.ok)throw new Error(`Failed to create feedback for run ${e}: ${f.status} ${f.statusText}`);return await f.json()}async readFeedback(e){let t=`/feedback/${e}`;return await this._get(t)}async deleteFeedback(e){let t=`/feedback/${e}`,r=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to delete ${t}: ${r.status} ${r.statusText}`);return await r.json()}async listFeedback({runIds:e}={}){let t=new URLSearchParams;return e&&t.append("run",e.join(",")),await this._get("/feedback",t)}};import*as x from"/v126/uuid@9.0.0/deno/uuid.mjs";var h=class{constructor(e){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"run_type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"session_name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"parent_run",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_runs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"start_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"end_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extra",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"error",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"serialized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reference_example_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=h.getDefaultConfig();Object.assign(this,{...t,...e})}static getDefaultConfig(){return{id:x.v4(),session_name:d("LANGCHAIN_SESSION")??"default",child_runs:[],execution_order:1,child_execution_order:1,api_url:d("LANGCHAIN_ENDPOINT")??"http://localhost:1984",api_key:d("LANGCHAIN_API_KEY"),caller_options:{},start_time:Date.now(),end_time:Date.now(),serialized:{},inputs:{},extra:{},client:new c({})}}async createChild(e){let t=new h({...e,parent_run:this,session_name:this.session_name,client:this.client,execution_order:this.child_execution_order+1,child_execution_order:this.child_execution_order+1});return this.child_runs.push(t),t}async end(e,t,r=Date.now()){this.outputs=e,this.error=t,this.end_time=r,this.parent_run&&(this.parent_run.child_execution_order=Math.max(this.parent_run.child_execution_order,this.child_execution_order))}async _convertToCreate(e,t=!0){let r=e.extra??{};r.runtime||(r.runtime={});let i=await w();for(let[u,l]of Object.entries(i))r.runtime[u]||(r.runtime[u]=l);let a,s;return t?(s=e.parent_run?.id,a=[]):(a=await Promise.all(e.child_runs.map(u=>this._convertToCreate(u,t))),s=void 0),{id:e.id,name:e.name,start_time:e.start_time,end_time:e.end_time,run_type:e.run_type,reference_example_id:e.reference_example_id,extra:r,execution_order:e.execution_order,serialized:e.serialized,error:e.error,inputs:e.inputs,outputs:e.outputs,session_name:e.session_name,child_runs:a,parent_run_id:s}}async postRun(e=!0){let t=await this._convertToCreate(this,e);await this.client.createRun(t)}async patchRun(){let e={end_time:this.end_time,error:this.error,outputs:this.outputs,parent_run_id:this.parent_run?.id,reference_example_id:this.reference_example_id};await this.client.updateRun(this.id,e)}};export{c as LangChainPlusClient,h as RunTree};
//# sourceMappingURL=langchainplus-sdk.mjs.map