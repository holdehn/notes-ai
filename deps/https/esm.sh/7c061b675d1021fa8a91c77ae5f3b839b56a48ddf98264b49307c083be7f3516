/* esm.sh - esbuild bundle(langchain@0.0.67/callbacks) deno production */
import __Process$ from "https://deno.land/std@0.177.0/node/process.ts";import{v4 as S}from"/v118/uuid@9.0.0/deno/uuid.mjs";var $=class{},c=class extends ${constructor(e){super(),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),e&&(this.ignoreLLM=e.ignoreLLM??this.ignoreLLM,this.ignoreChain=e.ignoreChain??this.ignoreChain,this.ignoreAgent=e.ignoreAgent??this.ignoreAgent)}copy(){return new this.constructor(this)}static fromMethods(e){class t extends c{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:S()}),Object.assign(this,e)}}return new t}};var m=class extends c{constructor(){super(),Object.defineProperty(this,"session",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"runMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}copy(){return this}async newSession(e){let t={start_time:Date.now(),name:e},r=await this.persistSession(t);return this.session=r,r}_addChildRun(e,t){if(t.type==="llm")e.child_llm_runs.push(t);else if(t.type==="chain")e.child_chain_runs.push(t);else if(t.type==="tool")e.child_tool_runs.push(t);else throw new Error("Invalid run type")}_startTrace(e){if(e.parent_uuid){let t=this.runMap.get(e.parent_uuid);if(t)if(t.type==="tool"||t.type==="chain")this._addChildRun(t,e);else throw new Error("Caller run can only be a tool or chain");else throw new Error(`Caller run ${e.parent_uuid} not found`)}this.runMap.set(e.uuid,e)}async _endTrace(e){if(!e.parent_uuid)await this.persistRun(e);else{let t=this.runMap.get(e.parent_uuid);if(t===void 0)throw new Error(`Parent run ${e.parent_uuid} not found`);t.child_execution_order=Math.max(t.child_execution_order,e.child_execution_order)}this.runMap.delete(e.uuid)}_getExecutionOrder(e){if(e===void 0)return 1;let t=this.runMap.get(e);if(t===void 0)throw new Error(`Parent run ${e} not found`);return t.child_execution_order+1}async handleLLMStart(e,t,r,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let s=this._getExecutionOrder(n),o={uuid:r,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,prompts:t,session_id:this.session.id,execution_order:s,child_execution_order:s,type:"llm"};this._startTrace(o),await this.onLLMStart?.(o)}async handleLLMEnd(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="llm")throw new Error("No LLM run to end.");let n=r;n.end_time=Date.now(),n.response=e,await this.onLLMEnd?.(n),await this._endTrace(n)}async handleLLMError(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="llm")throw new Error("No LLM run to end.");let n=r;n.end_time=Date.now(),n.error=e.message,await this.onLLMError?.(n),await this._endTrace(n)}async handleChainStart(e,t,r,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let s=this._getExecutionOrder(n),o={uuid:r,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,inputs:t,session_id:this.session.id,execution_order:s,child_execution_order:s,type:"chain",child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(o),await this.onChainStart?.(o)}async handleChainEnd(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="chain")throw new Error("No chain run to end.");let n=r;n.end_time=Date.now(),n.outputs=e,await this.onChainEnd?.(n),await this._endTrace(n)}async handleChainError(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="chain")throw new Error("No chain run to end.");let n=r;n.end_time=Date.now(),n.error=e.message,await this.onChainError?.(n),await this._endTrace(n)}async handleToolStart(e,t,r,n){this.session===void 0&&(this.session=await this.loadDefaultSession());let s=this._getExecutionOrder(n),o={uuid:r,parent_uuid:n,start_time:Date.now(),end_time:0,serialized:e,tool_input:t,session_id:this.session.id,execution_order:s,child_execution_order:s,type:"tool",action:JSON.stringify(e),child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(o),await this.onToolStart?.(o)}async handleToolEnd(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="tool")throw new Error("No tool run to end");let n=r;n.end_time=Date.now(),n.output=e,await this.onToolEnd?.(n),await this._endTrace(n)}async handleToolError(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="tool")throw new Error("No tool run to end");let n=r;n.end_time=Date.now(),n.error=e.message,await this.onToolError?.(n),await this._endTrace(n)}async handleAgentAction(e,t){let r=this.runMap.get(t);if(!r||r?.type!=="chain")return;let n=r;n.actions=n.actions||[],n.actions.push(e),await this.onAgentAction?.(r)}},f=class extends m{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"endpoint",{enumerable:!0,configurable:!0,writable:!0,value:(typeof __Process$<"u"?__Process$.env?.LANGCHAIN_ENDPOINT:void 0)||"http://localhost:8000"}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:{"Content-Type":"application/json"}}),typeof __Process$<"u"&&__Process$.env?.LANGCHAIN_API_KEY&&(this.headers["x-api-key"]=__Process$.env?.LANGCHAIN_API_KEY)}async persistRun(e){let t;e.type==="llm"?t=`${this.endpoint}/llm-runs`:e.type==="chain"?t=`${this.endpoint}/chain-runs`:t=`${this.endpoint}/tool-runs`;let r=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(e)});r.ok||console.error(`Failed to persist run: ${r.status} ${r.statusText}`)}async persistSession(e){let t=`${this.endpoint}/sessions`,r=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(e)});return r.ok?{id:(await r.json()).id,...e}:(console.error(`Failed to persist session: ${r.status} ${r.statusText}, using default session.`),{id:1,...e})}async loadSession(e){let t=`${this.endpoint}/sessions?name=${e}`;return this._handleSessionResponse(t)}async loadDefaultSession(){let e=`${this.endpoint}/sessions?name=default`;return this._handleSessionResponse(e)}async _handleSessionResponse(e){let t=await fetch(e,{method:"GET",headers:this.headers}),r;if(!t.ok)return console.error(`Failed to load session: ${t.status} ${t.statusText}`),r={id:1,start_time:Date.now()},this.session=r,r;let n=await t.json();return n.length===0?(r={id:1,start_time:Date.now()},this.session=r,r):([r]=n,this.session=r,r)}};async function E(i){let e=new f;return i?await e.loadSession(i):await e.loadDefaultSession(),e}import{v4 as w}from"/v118/uuid@9.0.0/deno/uuid.mjs";import T from"/v118/ansi-styles@5.2.0/deno/ansi-styles.mjs";function a(i,e){return`${i.open}${e}${i.close}`}function h(i,e){try{return JSON.stringify(i,null,2)}catch{return e}}function d(i){let e=i.end_time-i.start_time;return e<1e3?`${e}ms`:`${(e/1e3).toFixed(2)}s`}var{color:l}=T,p=class extends m{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"console_callback_handler"}),Object.defineProperty(this,"i",{enumerable:!0,configurable:!0,writable:!0,value:0})}persistSession(e){return Promise.resolve({...e,id:this.i++})}persistRun(e){return Promise.resolve()}loadDefaultSession(){return this.newSession()}loadSession(e){return this.newSession(e)}getParents(e){let t=[],r=e;for(;r.parent_uuid;){let n=this.runMap.get(r.parent_uuid);if(n)t.push(n),r=n;else break}return t}getBreadcrumbs(e){let r=[...this.getParents(e).reverse(),e].map((n,s,o)=>{let x=`${n.execution_order}:${n.type}:${n.serialized?.name}`;return s===o.length-1?a(T.bold,x):x}).join(" > ");return a(l.grey,r)}onChainStart(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.green,"[chain/start]")} [${t}] Entering Chain run with input: ${h(e.inputs,"[inputs]")}`)}onChainEnd(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.cyan,"[chain/end]")} [${t}] [${d(e)}] Exiting Chain run with output: ${h(e.outputs,"[outputs]")}`)}onChainError(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.red,"[chain/error]")} [${t}] [${d(e)}] Chain run errored with error: ${h(e.error,"[error]")}`)}onLLMStart(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.green,"[llm/start]")} [${t}] Entering LLM run with input: ${h({prompts:e.prompts.map(r=>r.trim())},"[inputs]")}`)}onLLMEnd(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.cyan,"[llm/end]")} [${t}] [${d(e)}] Exiting LLM run with output: ${h(e.response,"[response]")}`)}onLLMError(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.red,"[llm/error]")} [${t}] [${d(e)}] LLM run errored with error: ${h(e.error,"[error]")}`)}onToolStart(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.green,"[tool/start]")} [${t}] Entering Tool run with input: "${e.tool_input?.trim()}"`)}onToolEnd(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.cyan,"[tool/end]")} [${t}] [${d(e)}] Exiting Tool run with output: "${e.output?.trim()}"`)}onToolError(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.red,"[tool/error]")} [${t}] [${d(e)}] Tool run errored with error: ${h(e.error,"[error]")}`)}onAgentAction(e){let t=this.getBreadcrumbs(e);console.log(`${a(l.blue,"[agent/action]")} [${t}] Agent selected action: ${h(e.actions[e.actions.length-1],"[action]")}`)}};var L=class{setHandler(e){return this.setHandlers([e])}},g=class{constructor(e,t,r,n){Object.defineProperty(this,"runId",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:n})}async handleText(e){await Promise.all(this.handlers.map(async t=>{try{await t.handleText?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleText: ${r}`)}}))}},y=class extends g{async handleLLMNewToken(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreLLM)try{await t.handleLLMNewToken?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleLLMNewToken: ${r}`)}}))}async handleLLMError(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreLLM)try{await t.handleLLMError?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleLLMError: ${r}`)}}))}async handleLLMEnd(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreLLM)try{await t.handleLLMEnd?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleLLMEnd: ${r}`)}}))}},b=class extends g{getChild(){let e=new u(this.runId);return e.setHandlers(this.inheritableHandlers),e}async handleChainError(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreChain)try{await t.handleChainError?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleChainError: ${r}`)}}))}async handleChainEnd(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreChain)try{await t.handleChainEnd?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleChainEnd: ${r}`)}}))}async handleAgentAction(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreAgent)try{await t.handleAgentAction?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleAgentAction: ${r}`)}}))}async handleAgentEnd(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreAgent)try{await t.handleAgentEnd?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleAgentEnd: ${r}`)}}))}},_=class extends g{getChild(){let e=new u(this.runId);return e.setHandlers(this.inheritableHandlers),e}async handleToolError(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreAgent)try{await t.handleToolError?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleToolError: ${r}`)}}))}async handleToolEnd(e){await Promise.all(this.handlers.map(async t=>{if(!t.ignoreAgent)try{await t.handleToolEnd?.(e,this.runId,this._parentRunId)}catch(r){console.error(`Error in handler ${t.constructor.name}, handleToolEnd: ${r}`)}}))}},u=class extends L{constructor(e){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"callback_manager"}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=[],this.inheritableHandlers=[],this._parentRunId=e}async handleLLMStart(e,t,r=w()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreLLM)try{await n.handleLLMStart?.(e,t,r,this._parentRunId)}catch(s){console.error(`Error in handler ${n.constructor.name}, handleLLMStart: ${s}`)}})),new y(r,this.handlers,this.inheritableHandlers,this._parentRunId)}async handleChainStart(e,t,r=w()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreChain)try{await n.handleChainStart?.(e,t,r,this._parentRunId)}catch(s){console.error(`Error in handler ${n.constructor.name}, handleChainStart: ${s}`)}})),new b(r,this.handlers,this.inheritableHandlers,this._parentRunId)}async handleToolStart(e,t,r=w()){return await Promise.all(this.handlers.map(async n=>{if(!n.ignoreAgent)try{await n.handleToolStart?.(e,t,r,this._parentRunId)}catch(s){console.error(`Error in handler ${n.constructor.name}, handleToolStart: ${s}`)}})),new _(r,this.handlers,this.inheritableHandlers,this._parentRunId)}addHandler(e,t=!0){this.handlers.push(e),t&&this.inheritableHandlers.push(e)}removeHandler(e){this.handlers=this.handlers.filter(t=>t!==e),this.inheritableHandlers=this.inheritableHandlers.filter(t=>t!==e)}setHandlers(e,t=!0){this.handlers=[],this.inheritableHandlers=[];for(let r of e)this.addHandler(r,t)}copy(e=[],t=!0){let r=new u(this._parentRunId);for(let n of this.handlers){let s=this.inheritableHandlers.includes(n),o=n.copy();r.addHandler(o,s)}for(let n of e)r.handlers.filter(s=>s.name==="console_callback_handler").some(s=>s.name===n.name)||r.addHandler(n.copy(),t);return r}static fromHandlers(e){class t extends c{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:w()}),Object.assign(this,e)}}let r=new this;return r.addHandler(new t),r}static async configure(e,t,r){let n;(e||t)&&(Array.isArray(e)||!e?(n=new u,n.setHandlers(e?.map(M)??[],!0)):n=e,n=n.copy(Array.isArray(t)?t.map(M):t?.handlers,!1));let s=typeof __Process$<"u"?__Process$.env?.LANGCHAIN_TRACING!==void 0:!1;if(r?.verbose||s){if(n||(n=new u),r?.verbose&&!n.handlers.some(o=>o.name===p.prototype.name)){let o=new p;n.addHandler(o,!0)}if(s&&!n.handlers.some(o=>o.name==="langchain_tracer")){let o=typeof __Process$<"u"?__Process$.env?.LANGCHAIN_SESSION:void 0;n.addHandler(await E(o),!0)}}return n}};function M(i){return"name"in i?i:c.fromMethods(i)}export{c as BaseCallbackHandler,u as CallbackManager,b as CallbackManagerForChainRun,y as CallbackManagerForLLMRun,_ as CallbackManagerForToolRun,p as ConsoleCallbackHandler,f as LangChainTracer,E as getTracingCallbackHandler};
//# sourceMappingURL=callbacks.js.map