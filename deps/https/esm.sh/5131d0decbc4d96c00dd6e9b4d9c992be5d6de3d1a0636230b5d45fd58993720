/* esm.sh - esbuild bundle(langchain@0.0.52/callbacks) deno production */
import __Process$ from "https://deno.land/std@0.177.0/node/process.ts";var d=class{},o=class extends d{constructor(t){super(),Object.defineProperty(this,"alwaysVerbose",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),t&&(this.alwaysVerbose=t.alwaysVerbose??this.alwaysVerbose,this.ignoreLLM=t.ignoreLLM??this.ignoreLLM,this.ignoreChain=t.ignoreChain??this.ignoreChain,this.ignoreAgent=t.ignoreAgent??this.ignoreAgent)}},u=class extends o{setHandler(t){return this.setHandlers([t])}},l=class extends u{constructor(){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=[]}async handleLLMStart(t,s,e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreLLM&&(e||r.alwaysVerbose))try{await r.handleLLMStart?.(t,s)}catch(c){console.error(`Error in handler ${r.constructor.name}, handleLLMStart: ${c}`)}}))}async handleLLMNewToken(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreLLM&&(s||e.alwaysVerbose))try{await e.handleLLMNewToken?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleLLMNewToken: ${r}`)}}))}async handleLLMError(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreLLM&&(s||e.alwaysVerbose))try{await e.handleLLMError?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleLLMError: ${r}`)}}))}async handleLLMEnd(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreLLM&&(s||e.alwaysVerbose))try{await e.handleLLMEnd?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleLLMEnd: ${r}`)}}))}async handleChainStart(t,s,e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreChain&&(e||r.alwaysVerbose))try{await r.handleChainStart?.(t,s)}catch(c){console.error(`Error in handler ${r.constructor.name}, handleChainStart: ${c}`)}}))}async handleChainError(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreChain&&(s||e.alwaysVerbose))try{await e.handleChainError?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleChainError: ${r}`)}}))}async handleChainEnd(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreChain&&(s||e.alwaysVerbose))try{await e.handleChainEnd?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleChainEnd: ${r}`)}}))}async handleToolStart(t,s,e){await Promise.all(this.handlers.map(async r=>{if(!r.ignoreAgent&&(e||r.alwaysVerbose))try{await r.handleToolStart?.(t,s)}catch(c){console.error(`Error in handler ${r.constructor.name}, handleToolStart: ${c}`)}}))}async handleToolError(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreAgent&&(s||e.alwaysVerbose))try{await e.handleToolError?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleToolError: ${r}`)}}))}async handleToolEnd(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreAgent&&(s||e.alwaysVerbose))try{await e.handleToolEnd?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleToolEnd: ${r}`)}}))}async handleText(t,s){await Promise.all(this.handlers.map(async e=>{if(s||e.alwaysVerbose)try{await e.handleText?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleText: ${r}`)}}))}async handleAgentAction(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreAgent&&(s||e.alwaysVerbose))try{await e.handleAgentAction?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleAgentAction: ${r}`)}}))}async handleAgentEnd(t,s){await Promise.all(this.handlers.map(async e=>{if(!e.ignoreAgent&&(s||e.alwaysVerbose))try{await e.handleAgentEnd?.(t)}catch(r){console.error(`Error in handler ${e.constructor.name}, handleAgentEnd: ${r}`)}}))}addHandler(t){this.handlers.push(t)}removeHandler(t){this.handlers=this.handlers.filter(s=>s!==t)}setHandlers(t){this.handlers=t}static fromHandlers(t){class s extends o{constructor(){super(),Object.defineProperty(this,"alwaysVerbose",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.assign(this,t)}}let e=new this;return e.addHandler(new s),e}},h=class extends o{async handleChainStart(t){console.log(`Entering new ${t.name} chain...`)}async handleChainEnd(t){console.log("Finished chain.")}async handleAgentAction(t){console.log(t.log)}async handleToolEnd(t){console.log(t)}async handleText(t){console.log(t)}async handleAgentEnd(t){console.log(t.log)}};var y=class extends o{constructor(){super(),Object.defineProperty(this,"session",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"stack",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"executionOrder",{enumerable:!0,configurable:!0,writable:!0,value:1}),this.alwaysVerbose=!0}async newSession(t){let s={start_time:Date.now(),name:t},e=await this.persistSession(s);return this.session=e,e}_addChildRun(t,s){if(s.type==="llm")t.child_llm_runs.push(s);else if(s.type==="chain")t.child_chain_runs.push(s);else if(s.type==="tool")t.child_tool_runs.push(s);else throw new Error("Invalid run type")}_startTrace(t){if(this.executionOrder+=1,this.stack.length>0){if(!(this.stack.at(-1)?.type==="tool"||this.stack.at(-1)?.type==="chain"))throw new Error("Nested run can only be logged for tool or chain");let s=this.stack.at(-1);this._addChildRun(s,t)}this.stack.push(t)}async _endTrace(){let t=this.stack.pop();this.stack.length===0&&t&&(this.executionOrder=1,await this.persistRun(t))}async handleLLMStart(t,s,e){this.session===void 0&&(this.session=await this.loadDefaultSession());let r={start_time:Date.now(),end_time:0,serialized:t,prompts:s,session_id:this.session.id,execution_order:this.executionOrder,type:"llm"};this._startTrace(r)}async handleLLMEnd(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="llm")throw new Error("No LLM run to end.");let e=this.stack.at(-1);e.end_time=Date.now(),e.response=t,await this._endTrace()}async handleLLMError(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="llm")throw new Error("No LLM run to end.");let e=this.stack.at(-1);e.end_time=Date.now(),e.error=t.message,await this._endTrace()}async handleChainStart(t,s,e){this.session===void 0&&(this.session=await this.loadDefaultSession());let r={start_time:Date.now(),end_time:0,serialized:t,inputs:s,session_id:this.session.id,execution_order:this.executionOrder,type:"chain",child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(r)}async handleChainEnd(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="chain")throw new Error("No chain run to end.");let e=this.stack.at(-1);e.end_time=Date.now(),e.outputs=t,await this._endTrace()}async handleChainError(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="chain")throw new Error("No chain run to end.");let e=this.stack.at(-1);e.end_time=Date.now(),e.error=t.message,await this._endTrace()}async handleToolStart(t,s,e){this.session===void 0&&(this.session=await this.loadDefaultSession());let r={start_time:Date.now(),end_time:0,serialized:t,tool_input:s,session_id:this.session.id,execution_order:this.executionOrder,type:"tool",action:JSON.stringify(t),child_llm_runs:[],child_chain_runs:[],child_tool_runs:[]};this._startTrace(r)}async handleToolEnd(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="tool")throw new Error("No tool run to end");let e=this.stack.at(-1);e.end_time=Date.now(),e.output=t,await this._endTrace()}async handleToolError(t,s){if(this.stack.length===0||this.stack.at(-1)?.type!=="tool")throw new Error("No tool run to end.");let e=this.stack.at(-1);e.end_time=Date.now(),e.error=t.message,await this._endTrace()}},i=class extends y{constructor(){super(),Object.defineProperty(this,"endpoint",{enumerable:!0,configurable:!0,writable:!0,value:(typeof __Process$<"u"?__Process$.env.LANGCHAIN_ENDPOINT:void 0)||"http://localhost:8000"}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:{"Content-Type":"application/json"}}),typeof __Process$<"u"&&__Process$.env.LANGCHAIN_API_KEY&&(this.headers["x-api-key"]=__Process$.env.LANGCHAIN_API_KEY)}async persistRun(t){let s;t.type==="llm"?s=`${this.endpoint}/llm-runs`:t.type==="chain"?s=`${this.endpoint}/chain-runs`:s=`${this.endpoint}/tool-runs`;let e=await fetch(s,{method:"POST",headers:this.headers,body:JSON.stringify(t)});e.ok||console.error(`Failed to persist run: ${e.status} ${e.statusText}`)}async persistSession(t){let s=`${this.endpoint}/sessions`,e=await fetch(s,{method:"POST",headers:this.headers,body:JSON.stringify(t)});return e.ok?{id:(await e.json()).id,...t}:(console.error(`Failed to persist session: ${e.status} ${e.statusText}, using default session.`),{id:1,...t})}async loadSession(t){let s=`${this.endpoint}/sessions?name=${t}`;return this._handleSessionResponse(s)}async loadDefaultSession(){let t=`${this.endpoint}/sessions?name=default`;return this._handleSessionResponse(t)}async _handleSessionResponse(t){let s=await fetch(t,{method:"GET",headers:this.headers}),e;if(!s.ok)return console.error(`Failed to load session: ${s.status} ${s.statusText}`),e={id:1,start_time:Date.now()},this.session=e,e;let r=await s.json();return r.length===0?(e={id:1,start_time:Date.now()},this.session=e,e):([e]=r,this.session=e,e)}};var n=class extends l{constructor(){super()}static getInstance(){return n.instance||(n.instance=new n,n.instance.addHandler(new h),typeof __Process$<"u"&&__Process$.env.LANGCHAIN_HANDLER==="langchain"&&n.instance.addHandler(new i)),n.instance}};function w(){return n.getInstance()}async function p(a,t=w()){for(let s of t.handlers)if(s instanceof i){let e=a?.sessionName;e?await s.loadSession(e):await s.loadDefaultSession()}}export{o as BaseCallbackHandler,l as CallbackManager,h as ConsoleCallbackHandler,i as LangChainTracer,w as getCallbackManager,p as setTracerSession};
//# sourceMappingURL=callbacks.js.map